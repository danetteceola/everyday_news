## Context

Everyday News系统需要存储每日采集的新闻数据、生成的总结和系统操作日志。数据量预计为每日约500条新闻，年存储约180MB，属于中小规模数据存储需求。系统需要支持快速查询、统计分析和数据备份。

当前项目处于规划阶段，已有详细的数据库设计文档（docs/02-database-schema.md），包含4个核心表和索引优化策略。需要选择合适的技术栈实现数据库层，并考虑性能、可靠性和可维护性。

## Goals / Non-Goals

**Goals:**
1. 实现高性能的SQLite数据库存储，支持快速数据插入和查询
2. 提供类型安全的数据访问接口，减少运行时错误
3. 实现数据库版本管理和无缝迁移
4. 提供可靠的数据备份和恢复机制
5. 优化数据库性能，支持预期的数据量和查询模式

**Non-Goals:**
1. 不实现分布式数据库（单机SQLite足够）
2. 不提供复杂的数据库管理界面（命令行工具足够）
3. 不实现实时数据同步（定时批量处理足够）
4. 不处理TB级大数据（当前规模较小）

## Decisions

### 1. 数据库引擎选择
**选择**: SQLite + better-sqlite3
**理由**:
- SQLite是嵌入式数据库，零配置，适合单机部署
- better-sqlite3提供了高性能的Node.js绑定，支持同步API
- 类型安全的TypeScript支持，减少运行时错误
- 事务支持和ACID合规性
**替代方案考虑**:
- 考虑过PostgreSQL，但需要额外安装和配置，复杂度较高
- 考虑过MySQL，同样需要独立服务，运维负担较重
- 考虑过LevelDB/RocksDB，但SQL查询能力较弱

### 2. 数据库架构设计
**选择**: 规范化设计 + 适当反规范化
**理由**:
- platforms表：存储平台信息，支持扩展新平台
- news_items表：核心新闻数据，包含平台外键和唯一约束
- daily_summaries表：每日总结，按日期分区
- crawl_logs表：采集日志，用于监控和调试
- JSON字段存储灵活数据（tags, hotspots）
**替代方案考虑**:
- 考虑过完全规范化设计，但会增加查询复杂度
- 考虑过文档数据库（如MongoDB），但关系型数据更适合当前需求

### 3. 数据访问层设计
**选择**: Repository模式 + 类型安全接口
**理由**:
- Repository模式封装数据库操作，提供清晰的API
- 类型安全的TypeScript接口，编译时检查
- 支持事务管理和错误处理
- 便于单元测试和模拟
**替代方案考虑**:
- 考虑过Active Record模式，但耦合度较高
- 考虑过直接SQL查询，但维护性和类型安全性较差

### 4. 迁移系统设计
**选择**: 基于版本号的迁移脚本
**理由**:
- 每个版本一个迁移脚本，按顺序执行
- 支持升级和降级（回滚）
- 迁移状态存储在数据库表中
- 支持开发、测试、生产环境一致迁移
**替代方案考虑**:
- 考虑过ORM自动迁移，但控制粒度较粗
- 考虑过无迁移方案（每次重建），但不适合生产环境

### 5. 备份策略设计
**选择**: 每日自动备份 + 保留最近7天
**理由**:
- 每日定时备份，确保数据安全
- 保留7天备份，平衡存储空间和数据恢复需求
- 支持手动备份和恢复
- 备份文件压缩存储，减少空间占用
**替代方案考虑**:
- 考虑过实时复制，但系统复杂度不高，不需要
- 考虑过云存储备份，但增加外部依赖和成本

## Risks / Trade-offs

### 风险1: 数据库文件损坏
- **风险**: SQLite文件损坏导致数据丢失
- **缓解**: 定期备份，备份验证，事务完整性检查

### 风险2: 性能瓶颈
- **风险**: 数据量增长导致查询性能下降
- **缓解**: 索引优化，查询优化，定期维护

### 风险3: 迁移失败
- **风险**: 数据库迁移脚本执行失败
- **缓解**: 迁移前备份，迁移事务，回滚机制

### 风险4: 并发访问问题
- **风险**: 多进程/线程并发访问SQLite可能有问题
- **缓解**: 连接池管理，读写锁，适当的事务隔离

### 权衡: 数据一致性 vs 性能
- **选择**: 优先数据一致性，适当牺牲性能
- **理由**: 新闻数据需要准确性和完整性
- **代价**: 可能需要更复杂的事务处理和锁管理

### 权衡: 灵活性 vs 性能
- **选择**: JSON字段提供灵活性，适当查询性能代价
- **理由**: tags和hotspots数据结构可能变化，JSON提供灵活性
- **代价**: JSON查询性能不如结构化字段

## Migration Plan

### 部署步骤
1. **环境准备**: 安装Node.js和better-sqlite3依赖
2. **数据库初始化**: 创建初始数据库和表结构
3. **数据访问层部署**: 部署Repository和数据访问接口
4. **迁移系统集成**: 集成迁移脚本和管理工具
5. **备份系统配置**: 配置备份目录和定时任务
6. **性能优化**: 应用索引和查询优化
7. **监控配置**: 配置数据库监控和告警

### 回滚策略
- 每个迁移版本都有对应的回滚脚本
- 迁移前自动备份数据库
- 关键操作记录详细日志，便于问题排查

## Open Questions

1. **连接池配置**: SQLite连接池的最佳实践是什么？需要多少连接？
2. **JSON查询优化**: 如何优化JSON字段的查询性能？是否需要提取常用字段？
3. **备份存储**: 备份文件是否应该加密？存储在哪里最安全？
4. **监控指标**: 需要监控哪些数据库性能指标？如何设置合理的阈值？